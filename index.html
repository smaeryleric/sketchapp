<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Sketch Animation Board 1280x720</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      height: 100vh;
      background: #f5f5f5;
      color: #111827;
    }

    .sidebar {
      width: 280px;
      padding: 20px 18px;
      border-right: 1px solid #e5e7eb;
      background: #ffffff;
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 4px 0 18px rgba(15, 23, 42, 0.06);
    }

    .sidebar-right {
      border-right: none;
      border-left: 1px solid #e5e7eb;
      box-shadow: -4px 0 18px rgba(15, 23, 42, 0.06);
    }

    .sidebar-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .sidebar h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.04em;
    }

    .sidebar-subtitle {
      font-size: 12px;
      margin: 0;
      color: #6b7280;
    }

    .project-name-input {
      width: 100%;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      font-size: 13px;
      outline: none;
      transition: border-color 0.12s ease, box-shadow 0.12s ease;
    }

    .project-name-input:focus {
      border-color: #0ea5e9;
      box-shadow: 0 0 0 1px rgba(14,165,233,0.3);
    }

    .section-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .section {
      border-radius: 12px;
      padding: 10px 10px 12px;
      background: #fafafa;
      border: 1px solid #e5e7eb;
    }

    .section + .section {
      margin-top: 4px;
    }

    .small-text {
      font-size: 12px;
      color: #6b7280;
      margin: 4px 0 0;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      min-height: 60px;
    }

    .palette-item {
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      font-size: 20px;
      font-weight: 600;
      cursor: grab;
      user-select: none;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, background 0.12s ease;
    }

    .palette-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 12px rgba(15, 23, 42, 0.12);
      border-color: #38bdf8;
      background: #f9fafb;
    }

    .palette-item:active {
      cursor: grabbing;
      transform: scale(0.97);
      box-shadow: 0 0 0 rgba(0, 0, 0, 0.1);
    }

    input[type="file"] {
      font-size: 12px;
      width: 100%;
      color: #374151;
    }

    button {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      color: #111827;
      font-size: 13px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: background 0.15s ease, transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
      white-space: nowrap;
    }

    button:hover {
      background: #f3f4f6;
      transform: translateY(-1px);
      box-shadow: 0 6px 12px rgba(15, 23, 42, 0.12);
      border-color: #38bdf8;
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 0 0 rgba(0, 0, 0, 0.08);
    }

    .btn-primary {
      border-color: #0ea5e9;
      background: linear-gradient(135deg, #0ea5e9, #2563eb);
      color: #f9fafb;
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #22c1f1, #3b82f6);
    }

    .small-btn {
      padding: 6px 10px;
      font-size: 11px;
    }

    .small-btn.selected {
      border-color: #0ea5e9;
      background: #dbeafe;
      color: #1e40af;
    }

    .color-label {
      font-size: 11px;
      color: #4b5563;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
    }

    .color-label input[type="color"] {
      border: none;
      padding: 0;
      width: 22px;
      height: 22px;
      background: none;
      cursor: pointer;
    }

    .size-label {
      font-size: 11px;
      color: #4b5563;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
    }

    .size-label input[type="range"] {
      width: 80px;
    }

    .mode-indicator {
      font-size: 11px;
      color: #6b7280;
      margin-top: 2px;
    }

    .main {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      overflow: auto;
    }

    .stage-wrapper {
      background: #ffffff;
      padding: 10px 16px 10px;
      border-radius: 18px;
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.18),
        0 0 0 1px rgba(209, 213, 219, 0.8);
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 1000px;
      width: 100%;
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
    }

    .top-bar-left,
    .top-bar-right {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    #stage {
      border-radius: 12px;
      display: block;
      background: #ffffff;
      cursor: default;
      border: 1px solid #d1d5db;
      width: 100%;
      height: auto;
      max-width: 960px;
      margin: 0 auto;
    }

    .canvas-label {
      text-align: center;
      font-size: 12px;
      color: #6b7280;
    }

    .timeline-bar {
      margin-top: 6px;
      border-top: 1px solid #e5e7eb;
      padding-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .timeline-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .frames-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      max-height: 80px;
      overflow-y: auto;
      flex: 1;
    }

    .frame-item {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      color: #374151;
      transition: background 0.15s ease, transform 0.12s ease, border-color 0.12s ease;
    }

    .frame-item:hover {
      transform: translateY(-1px);
      border-color: #38bdf8;
      background: #f3f4f6;
    }

    .frame-item.active {
      border-color: #0ea5e9;
      background: #dbeafe;
      font-weight: 600;
      color: #1e40af;
    }

    .timeline-actions {
      display: flex;
      gap: 6px;
      flex-wrap: nowrap;
    }

    /* Правый редактор заметок */

    .notes-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 6px;
      margin-bottom: 6px;
    }

    .notes-toolbar button,
    .notes-toolbar select {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
    }

    .notes-toolbar button:hover {
      background: #f3f4f6;
    }

    .notes-editor {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      min-height: 260px;
      padding: 8px 10px;
      font-size: 13px;
      overflow-y: auto;
    }

    .notes-editor:focus {
      outline: none;
      border-color: #0ea5e9;
      box-shadow: 0 0 0 1px rgba(14,165,233,0.3);
    }

    .notes-editor img {
      max-width: 100%;
      display: block;
      margin: 4px 0;
    }
  </style>
</head>
<body>
  <!-- Левое меню -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <h1>Sketch Animation</h1>
      <input
        id="projectName"
        class="project-name-input"
        type="text"
        placeholder="Название проекта"
      />
      <p class="sidebar-subtitle">Покадровые скетчи 1280×720</p>
    </div>

    <div class="section">
      <div class="section-title">Проект</div>
      <div style="display:flex; flex-direction:column; gap:6px;">
        <button id="btnSaveProject" class="small-btn">Сохранить проект (.json)</button>
        <button id="btnLoadProject" class="small-btn">Загрузить проект (.json)</button>
        <input type="file" id="projectFile" accept=".json" style="display:none" />
        <p class="small-text">
          Перед загрузкой проект текущая сцена будет очищена. Убедитесь, что вы её сохранили.
        </p>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Персонажи из файла</div>
      <input type="file" id="charactersFile" accept=".txt" />
      <p class="small-text">
        Формат: один персонаж в строке. После загрузки имена появятся в палитре ниже.
      </p>
    </div>

    <div class="section">
      <div class="section-title">Палитра персонажей</div>
      <div class="palette" id="palette"></div>
      <p class="small-text">
        Перетащи персонажа на холст — появится прямоугольник с именем.
      </p>
    </div>
  </aside>

  <!-- Центральный блок -->
  <main class="main">
    <div class="stage-wrapper">
      <div class="top-bar">
        <div class="top-bar-left">
          <button id="btnMode">Режим: перемещение</button>
          <button id="btnBrush" class="small-btn selected">Кисть</button>
          <button id="btnEraser" class="small-btn">Ластик</button>
          <button id="btnClear" class="small-btn">Очистить кадр</button>
        </div>
        <div class="top-bar-right">
          <label class="color-label">
            Цвет
            <input type="color" id="brushColor" value="#111827" />
          </label>
          <label class="size-label">
            Размер
            <input type="range" id="brushSize" min="1" max="20" value="3" />
          </label>
        </div>
      </div>
      <div class="mode-indicator" id="modeIndicator">
        Сейчас: перемещение персонажей. Нажми «Режим», чтобы рисовать.
      </div>

      <canvas id="stage" width="1280" height="720"></canvas>
      <div class="canvas-label">
        Холст 1280×720 (уменьшенный на экране). Чуть ниже середины есть направляющая горизонтальная линия.
      </div>

      <div class="timeline-bar">
        <div class="timeline-row">
          <div class="frames-list" id="framesList"></div>
          <div class="timeline-actions">
            <button id="btnAddFrame" class="small-btn">Добавить кадр</button>
            <button id="btnDeleteFrame" class="small-btn">Удалить кадр</button>
            <button id="btnDownload" class="small-btn btn-primary">Скачать кадр</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Правое меню: заметки кадра -->
  <aside class="sidebar sidebar-right">
    <div class="sidebar-header">
      <h1>Заметки кадра</h1>
      <p class="sidebar-subtitle">Текст и изображения, привязанные к выбранному кадру.</p>
    </div>

    <div class="section">
      <div class="section-title">Форматирование</div>
      <div class="notes-toolbar">
        <button type="button" id="btnNotesBold"><b>B</b></button>
        <button type="button" id="btnNotesItalic"><i>I</i></button>
        <button type="button" id="btnNotesUnderline"><u>U</u></button>
        <button type="button" id="btnNotesList">• Список</button>
        <select id="notesFontSize">
          <option value="">Размер</option>
          <option value="2">Малый</option>
          <option value="3">Нормальный</option>
          <option value="4">Крупный</option>
          <option value="5">Заголовок</option>
        </select>
        <button type="button" id="btnNotesImage">Картинка…</button>
        <input type="file" id="notesImageInput" accept="image/*" style="display:none" />
      </div>
      <div
        id="notesEditor"
        class="notes-editor"
        contenteditable="true"
        spellcheck="false"
      ></div>
      <p class="small-text">
        Каждому кадру соответствует свой текст/верстка. При переключении кадра содержимое сохраняется автоматически.
      </p>
    </div>
  </aside>

  <script>
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    const ITEM_WIDTH = 140;
    const ITEM_HEIGHT = 320;

    let mode = "move";   // 'move' | 'draw'
    let tool = "brush";  // 'brush' | 'eraser'
    let currentColor = "#111827";
    let currentSize = 3;

    const frames = [];
    let activeFrameIndex = 0;
    let nextItemId = 1;

    let draggingItem = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let drawing = false;
    let currentStroke = null;

    let hoverItem = null;

    const paletteContainer = document.getElementById("palette");
    const framesListEl   = document.getElementById("framesList");
    const modeButton     = document.getElementById("btnMode");
    const modeIndicator  = document.getElementById("modeIndicator");
    const colorInput     = document.getElementById("brushColor");
    const sizeInput      = document.getElementById("brushSize");
    const btnBrush       = document.getElementById("btnBrush");
    const btnEraser      = document.getElementById("btnEraser");

    const btnSaveProject   = document.getElementById("btnSaveProject");
    const btnLoadProject   = document.getElementById("btnLoadProject");
    const projectFileInput = document.getElementById("projectFile");
    const projectNameInput = document.getElementById("projectName");

    const notesEditor      = document.getElementById("notesEditor");
    const btnNotesBold     = document.getElementById("btnNotesBold");
    const btnNotesItalic   = document.getElementById("btnNotesItalic");
    const btnNotesUnderline= document.getElementById("btnNotesUnderline");
    const btnNotesList     = document.getElementById("btnNotesList");
    const notesFontSizeSel = document.getElementById("notesFontSize");
    const btnNotesImage    = document.getElementById("btnNotesImage");
    const notesImageInput  = document.getElementById("notesImageInput");

    function createEmptyFrame() {
      return { items: [], strokes: [], notesHtml: "" };
    }

    function cloneFrame(frame) {
      return {
        items: frame.items.map(i => ({ ...i })),
        strokes: frame.strokes.map(s => ({
          color: s.color,
          width: s.width,
          points: s.points.map(p => ({ ...p }))
        })),
        notesHtml: frame.notesHtml || ""
      };
    }

    function getCurrentFrame() {
      return frames[activeFrameIndex];
    }

    function init() {
      ctx.textBaseline = "top";
      frames.push(createEmptyFrame());
      setupPaletteDrag();
      setupCanvasDnDAndDrawing();
      setupButtons();
      setupCharacterFileLoader();
      setupNotesEditor();
      updateFramesList();
      loadCurrentNotes();
      drawScene();
    }

    function clearBackground() {
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawGuideLine() {
      const y = canvas.height * 0.58;
      ctx.save();
      ctx.strokeStyle = "#e5e7eb";
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
      ctx.restore();
    }

    function drawStroke(stroke) {
      const pts = stroke.points;
      if (pts.length < 2) return;
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.width;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }

    function drawName(text, x, y, w, h) {
      ctx.save();
      ctx.fillStyle = "#111827";
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const centerX = x + w / 2;
      const centerY = y + h / 2;

      let fontSize = 16;
      ctx.font = fontSize + "px Arial";
      let metrics = ctx.measureText(text);
      const maxWidth = w - 10;

      if (metrics.width > maxWidth) {
        fontSize = Math.max(10, Math.floor(fontSize * maxWidth / metrics.width));
        ctx.font = fontSize + "px Arial";
      }

      ctx.fillText(text, centerX, centerY);
      ctx.restore();
    }

    function drawDeleteBadge(item) {
      const size = 18;
      const padding = 6;
      const x = item.x + ITEM_WIDTH - size - padding;
      const y = item.y + padding;

      ctx.save();
      ctx.beginPath();
      ctx.roundRect(x, y, size, size, 4);
      ctx.fillStyle = "rgba(239,68,68,0.9)";
      ctx.fill();
      ctx.strokeStyle = "#fee2e2";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.strokeStyle = "#fef2f2";
      ctx.lineWidth = 2;
      const inset = 4;
      ctx.moveTo(x + inset, y + inset);
      ctx.lineTo(x + size - inset, y + size - inset);
      ctx.moveTo(x + size - inset, y + inset);
      ctx.lineTo(x + inset, y + size - inset);
      ctx.stroke();
      ctx.restore();
    }

    function drawItem(item) {
      const w = ITEM_WIDTH;
      const h = ITEM_HEIGHT;

      ctx.fillStyle = "rgba(15,23,42,0.08)";
      ctx.fillRect(item.x + 4, item.y + 4, w, h);

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(item.x, item.y, w, h);

      ctx.strokeStyle = "#111827";
      ctx.lineWidth = 2;
      ctx.strokeRect(item.x, item.y, w, h);

      drawName(item.label, item.x, item.y, w, h);
    }

    function drawScene() {
      clearBackground();
      drawGuideLine();

      const frame = getCurrentFrame();
      frame.strokes.forEach(drawStroke);
      frame.items.forEach(drawItem);

      if (hoverItem && mode === "move") drawDeleteBadge(hoverItem);
    }

    function setupPaletteDrag() {
      const paletteItems = document.querySelectorAll(".palette-item");
      paletteItems.forEach(el => {
        el.addEventListener("dragstart", e => {
          const label = el.dataset.label;
          e.dataTransfer.setData("text/plain", label);
        });
      });
    }

    function setupCanvasDnDAndDrawing() {
      canvas.addEventListener("dragover", e => e.preventDefault());

      canvas.addEventListener("drop", e => {
        e.preventDefault();
        const label = e.dataTransfer.getData("text/plain");
        if (!label) return;
        const { x, y } = getMousePos(e);
        addItem(label, x, y);
      });

      canvas.addEventListener("mousedown", e => {
        const { x, y } = getMousePos(e);

        if (mode === "move") {
          if (hoverItem && isInDeleteButton(x, y, hoverItem)) {
            const frame = getCurrentFrame();
            frame.items = frame.items.filter(i => i !== hoverItem);
            hoverItem = null;
            drawScene();
            return;
          }

          const item = hitTest(x, y);
          if (item) {
            draggingItem = item;
            dragOffsetX = x - item.x;
            dragOffsetY = y - item.y;
            canvas.style.cursor = "grabbing";
          }
        } else if (mode === "draw") {
          drawing = true;
          const frame = getCurrentFrame();
          const color = tool === "eraser" ? "#ffffff" : currentColor;
          currentStroke = {
            color,
            width: currentSize,
            points: [{ x, y }]
          };
          frame.strokes.push(currentStroke);
          drawScene();
        }
      });

      canvas.addEventListener("mousemove", e => {
        const { x, y } = getMousePos(e);

        if (mode === "move") {
          const itemUnderCursor = hitTest(x, y);
          const changed = itemUnderCursor !== hoverItem;
          hoverItem = itemUnderCursor;

          if (draggingItem) {
            draggingItem.x = x - dragOffsetX;
            draggingItem.y = y - dragOffsetY;
            drawScene();
          } else if (changed) {
            drawScene();
          }
        } else if (mode === "draw" && drawing && currentStroke) {
          currentStroke.points.push({ x, y });
          drawScene();
        }
      });

      canvas.addEventListener("mouseup", () => {
        draggingItem = null;
        drawing = false;
        currentStroke = null;
        canvas.style.cursor = "default";
      });

      canvas.addEventListener("mouseleave", () => {
        draggingItem = null;
        drawing = false;
        currentStroke = null;
        canvas.style.cursor = "default";
      });
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    function hitTest(x, y) {
      const frame = getCurrentFrame();
      for (let i = frame.items.length - 1; i >= 0; i--) {
        const item = frame.items[i];
        if (
          x >= item.x && x <= item.x + ITEM_WIDTH &&
          y >= item.y && y <= item.y + ITEM_HEIGHT
        ) return item;
      }
      return null;
    }

    function isInDeleteButton(x, y, item) {
      const size = 18;
      const padding = 6;
      const bx = item.x + ITEM_WIDTH - size - padding;
      const by = item.y + padding;
      return x >= bx && x <= bx + size && y >= by && y <= by + size;
    }

    function addItem(label, x, y) {
      const frame = getCurrentFrame();
      const item = {
        id: nextItemId++,
        x: x - ITEM_WIDTH / 2,
        y: y - ITEM_HEIGHT / 2,
        label
      };
      frame.items.push(item);
      drawScene();
    }

    function setupButtons() {
      document.getElementById("btnDownload").addEventListener("click", () => {
        const dataURL = canvas.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = dataURL;
        a.download = `frame_${activeFrameIndex + 1}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });

      document.getElementById("btnClear").addEventListener("click", () => {
        if (!confirm("Очистить текущий кадр? Это удалит всех персонажей и рисунок на этом кадре.")) return;
        const frame = getCurrentFrame();
        frame.items = [];
        frame.strokes = [];
        hoverItem = null;
        drawScene();
      });

      modeButton.addEventListener("click", () => {
        if (mode === "move") {
          mode = "draw";
          modeButton.textContent = "Режим: рисование";
          modeIndicator.textContent = "Сейчас: рисование по сцене. Нажми «Режим», чтобы вернуться к перемещению.";
        } else {
          mode = "move";
          modeButton.textContent = "Режим: перемещение";
          modeIndicator.textContent = "Сейчас: перемещение персонажей. Нажми «Режим», чтобы рисовать.";
        }
        drawScene();
      });

      document.getElementById("btnAddFrame").addEventListener("click", () => {
        saveCurrentNotes();
        const current = getCurrentFrame();
        const newFrame = cloneFrame(current);
        frames.push(newFrame);
        activeFrameIndex = frames.length - 1;
        hoverItem = null;
        updateFramesList();
        loadCurrentNotes();
        drawScene();
      });

      document.getElementById("btnDeleteFrame").addEventListener("click", () => {
        if (frames.length === 1) {
          alert("Нельзя удалить единственный кадр.");
          return;
        }
        if (!confirm("Удалить текущий кадр? Его содержимое будет потеряно.")) return;
        saveCurrentNotes();
        frames.splice(activeFrameIndex, 1);
        if (activeFrameIndex >= frames.length) activeFrameIndex = frames.length - 1;
        hoverItem = null;
        updateFramesList();
        loadCurrentNotes();
        drawScene();
      });

      colorInput.addEventListener("input", e => {
        currentColor = e.target.value || "#111827";
      });

      sizeInput.addEventListener("input", e => {
        const v = parseInt(e.target.value, 10);
        currentSize = isNaN(v) ? 3 : v;
      });

      btnBrush.addEventListener("click", () => {
        tool = "brush";
        btnBrush.classList.add("selected");
        btnEraser.classList.remove("selected");
      });

      btnEraser.addEventListener("click", () => {
        tool = "eraser";
        btnEraser.classList.add("selected");
        btnBrush.classList.remove("selected");
      });

      // Сохранение проекта
      btnSaveProject.addEventListener("click", () => {
        const name = (projectNameInput.value || "").trim();
        if (!name) {
          alert("Сначала укажите название проекта.");
          return;
        }
        saveCurrentNotes();

        const project = {
          version: 1,
          projectName: name,
          canvas: { width: canvas.width, height: canvas.height },
          frames: frames,
          activeFrameIndex: activeFrameIndex
        };
        const blob = new Blob([JSON.stringify(project)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = name + ".json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      // Загрузка проекта (кнопка открывает input)
      btnLoadProject.addEventListener("click", () => {
        projectFileInput.click();
      });

      // Загрузка проекта (сам input)
      projectFileInput.addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;

        const ok = confirm(
          "Загрузить проект из файла?\nТекущий проект будет полностью удалён и заменён. " +
          "Убедитесь, что вы его сохранили."
        );
        if (!ok) {
          projectFileInput.value = "";
          return;
        }

        const reader = new FileReader();
        reader.onload = evt => {
          try {
            const data = JSON.parse(evt.target.result);
            if (!data || !Array.isArray(data.frames)) {
              alert("Неверный формат проектного файла.");
              return;
            }

            frames.length = 0;
            data.frames.forEach(f => {
              const frame = {
                items: Array.isArray(f.items)
                  ? f.items.map(i => ({
                      id: typeof i.id === "number" ? i.id : nextItemId++,
                      x: typeof i.x === "number" ? i.x : 0,
                      y: typeof i.y === "number" ? i.y : 0,
                      label: typeof i.label === "string" ? i.label : ""
                    }))
                  : [],
                strokes: Array.isArray(f.strokes)
                  ? f.strokes.map(s => ({
                      color: typeof s.color === "string" ? s.color : "#111827",
                      width: typeof s.width === "number" ? s.width : 3,
                      points: Array.isArray(s.points)
                        ? s.points.map(p => ({
                            x: typeof p.x === "number" ? p.x : 0,
                            y: typeof p.y === "number" ? p.y : 0
                          }))
                        : []
                    }))
                  : [],
                notesHtml: typeof f.notesHtml === "string" ? f.notesHtml : ""
              };
              frames.push(frame);
            });

            if (frames.length === 0) frames.push(createEmptyFrame());

            activeFrameIndex = typeof data.activeFrameIndex === "number"
              ? Math.min(Math.max(0, data.activeFrameIndex), frames.length - 1)
              : 0;

            // project name
            if (typeof data.projectName === "string") {
              projectNameInput.value = data.projectName;
            }

            let maxId = 0;
            frames.forEach(f => {
              f.items.forEach(i => {
                if (typeof i.id === "number" && i.id > maxId) maxId = i.id;
              });
            });
            nextItemId = maxId + 1;

            hoverItem = null;
            draggingItem = null;
            drawing = false;
            currentStroke = null;

            updateFramesList();
            loadCurrentNotes();
            drawScene();
          } catch (err) {
            console.error(err);
            alert("Не удалось прочитать проектный файл.");
          } finally {
            projectFileInput.value = "";
          }
        };
        reader.readAsText(file, "utf-8");
      });
    }

    function updateFramesList() {
      framesListEl.innerHTML = "";
      frames.forEach((frame, index) => {
        const btn = document.createElement("button");
        btn.className = "frame-item" + (index === activeFrameIndex ? " active" : "");
        btn.textContent = "Кадр " + (index + 1);
        btn.addEventListener("click", () => {
          saveCurrentNotes();
          activeFrameIndex = index;
          hoverItem = null;
          updateFramesList();
          loadCurrentNotes();
          drawScene();
        });
        framesListEl.appendChild(btn);
      });
    }

    function setupCharacterFileLoader() {
      const fileInput = document.getElementById("charactersFile");
      fileInput.addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = evt => {
          const text = evt.target.result;
          const names = text
            .split(/\r?\n/)
            .map(line => line.trim())
            .filter(Boolean);
          if (names.length === 0) return;
          buildPalette(names);
        };
        reader.readAsText(file, "utf-8");
      });
    }

    function buildPalette(names) {
      paletteContainer.innerHTML = "";
      names.forEach(name => {
        const div = document.createElement("div");
        div.className = "palette-item";
        div.draggable = true;
        div.dataset.label = name;
        div.textContent = name[0] || "?";
        paletteContainer.appendChild(div);
      });
      setupPaletteDrag();
    }

    /* --- Заметки кадра --- */

    function setupNotesEditor() {
      btnNotesBold.addEventListener("click", () => {
        document.execCommand("bold", false, null);
        notesEditor.focus();
      });

      btnNotesItalic.addEventListener("click", () => {
        document.execCommand("italic", false, null);
        notesEditor.focus();
      });

      btnNotesUnderline.addEventListener("click", () => {
        document.execCommand("underline", false, null);
        notesEditor.focus();
      });

      btnNotesList.addEventListener("click", () => {
        document.execCommand("insertUnorderedList", false, null);
        notesEditor.focus();
      });

      notesFontSizeSel.addEventListener("change", () => {
        const val = notesFontSizeSel.value;
        if (val) {
          document.execCommand("fontSize", false, val);
          notesFontSizeSel.value = "";
          notesEditor.focus();
        }
      });

      btnNotesImage.addEventListener("click", () => {
        notesImageInput.click();
      });

      notesImageInput.addEventListener("change", e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          insertImageAtCursor(evt.target.result);
          notesImageInput.value = "";
        };
        reader.readAsDataURL(file);
      });
    }

    function insertImageAtCursor(src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";

      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) {
        notesEditor.appendChild(img);
        return;
      }
      const range = sel.getRangeAt(0);
      range.deleteContents();
      range.insertNode(img);
    }

    function saveCurrentNotes() {
      const frame = getCurrentFrame();
      frame.notesHtml = notesEditor.innerHTML;
    }

    function loadCurrentNotes() {
      const frame = getCurrentFrame();
      notesEditor.innerHTML = frame.notesHtml || "";
    }

    init();
  </script>
</body>
</html>
